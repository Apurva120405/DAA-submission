#include <bits/stdc++.h>
using namespace std;
const int INF = INT_MAX;
using Graph = unordered_map<int, vector<pair<int, int>>>;
// Function to find the optimal route from source (0) to destination (N-1)
vector<int> findOptimalRoute(int N, const Graph& graph) {
vector<int> dp(N, INF);
vector<int> path(N, -1);
dp[N - 1] = 0; // Cost from destination to itself is 0
// Dynamic Programming (Backward Traversal)
for (int i = N - 2; i >= 0; --i) {
if (graph.find(i) != graph.end()) {
for (auto& [next, cost] : graph.at(i)) {
if (dp[next] != INF && cost + dp[next] < dp[i]) {
dp[i] = cost + dp[next];
path[i] = next;
}
}
}
}
// Display results
cout << "\nSwiftCargo Route Optimization\n";
cout << "---------------------------------\n";
if (dp[0] == INF) {
cout << "No route found from source (0) to destination (" << N - 1 << ").\n";
} else {
cout << "Minimum Delivery Cost: " << dp[0] << "\n";
cout << "Optimal Route Path: ";
int current = 0;
while (current != -1) {
cout << current;
current = path[current];
if (current != -1) cout << " -> ";
}

cout << "\n";
}
cout << "---------------------------------\n";
return dp;
}
int main() {
int N, E;
cout << "Enter total number of nodes: ";
cin >> N;
cout << "Enter total number of edges: ";
cin >> E;
Graph graph;
cout << "Enter each edge as (source destination cost):\n";
for (int i = 0; i < E; ++i) {
int u, v, cost;
cout << "Edge " << i + 1 << ": ";
cin >> u >> v >> cost;
graph[u].emplace_back(v, cost);
}
int batchCount;
cout << "Enter number of delivery requests to process: ";
cin >> batchCount;
for (int i = 0; i < batchCount; ++i) {
cout << "\nProcessing Delivery Request #" << i + 1 << "...\n";
findOptimalRoute(N, graph);
}
return 0;
}
